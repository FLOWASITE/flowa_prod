
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from '@/types/supabase';

// Supabase project configuration
const SUPABASE_URL = "https://cbcxaikcqaznmztilqca.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNiY3hhaWtjcWF6bm16dGlscWNhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU4NTYxOTUsImV4cCI6MjA2MTQzMjE5NX0.YdGESCNbkkMY2Y40BdSVZtNzXE6gWrrJoB2uuI_KKwM";

// Create Supabase client with type information
export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    storage: localStorage, // Store auth session in local storage
  },
  global: {
    headers: {
      'x-app-version': '1.0.0', // Add custom headers for API tracking
    },
  },
});

// Helper function to check if Supabase is connected
export const isSupabaseConnected = async () => {
  try {
    console.log("Testing Supabase connection...");
    
    // Try a simple query to check if Supabase is connected
    const { data, error } = await supabase.from('brands').select('id').limit(1);
    
    if (error) {
      console.error("Supabase connection error:", error.message, error.details);
      return false;
    }
    
    console.log("Supabase is connected successfully.");
    return true;
  } catch (error) {
    console.error("Supabase connection exception:", error);
    return false;
  }
};

// Export a typed API client that can be used to interact with the Supabase backend
export const api = {
  // Add the supabase client to the API for direct access
  supabase,
  
  // Brand management
  brands: {
    getAll: async () => await supabase
      .from('brands')
      .select('*')
      .order('created_at', { ascending: false }),
      
    getById: async (id: string | undefined) => {
      if (!id) return { data: null, error: new Error('Invalid ID') };
      return await supabase
        .from('brands')
        .select(`
          *,
          brand_knowledge (*),
          products (*),
          qa_pairs (*)
        `)
        .eq('id', id)
        .single();
    },
      
    create: async (brandData: any) => await supabase
      .from('brands')
      .insert(brandData)
      .select()
  },
  
  // Product management
  products: {
    getByBrandId: async (brandId: string | undefined) => {
      if (!brandId) return { data: null, error: new Error('Invalid brand ID') };
      return await supabase
        .from('products')
        .select('*')
        .eq('brand_id', brandId);
    }
  },
  
  // Knowledge management
  knowledge: {
    getByBrandId: async (brandId: string | undefined) => {
      if (!brandId) return { data: null, error: new Error('Invalid brand ID') };
      return await supabase
        .from('brand_knowledge')
        .select('*')
        .eq('brand_id', brandId)
        .single();
    }
  },
  
  // QA pairs management
  qaPairs: {
    getByBrandId: async (brandId: string | undefined) => {
      if (!brandId) return { data: null, error: new Error('Invalid brand ID') };
      return await supabase
        .from('qa_pairs')
        .select('*')
        .eq('brand_id', brandId);
    }
  },

  // File management
  fileManager: {
    // Topics
    getTopics: async () => {
      return await supabase
        .from('topics')
        .select('*')
        .order('name');
    },
    
    createTopic: async (topicData: { name: string, description?: string }) => {
      return await supabase
        .from('topics')
        .insert(topicData)
        .select();
    },
    
    updateTopic: async (topicId: string, topicData: { name?: string, description?: string }) => {
      return await supabase
        .from('topics')
        .update({
          ...topicData,
          updated_at: new Date().toISOString()
        })
        .eq('id', topicId)
        .select();
    },
    
    deleteTopic: async (topicId: string) => {
      return await supabase
        .from('topics')
        .delete()
        .eq('id', topicId);
    },
    
    // Platforms
    getPlatforms: async (topicId?: string) => {
      let query = supabase.from('platforms').select('*');
      
      if (topicId) {
        query = query.eq('topic_id', topicId);
      }
      
      return await query.order('name');
    },
    
    createPlatform: async (platformData: { topic_id: string, platform_type: string, name: string, description?: string }) => {
      return await supabase
        .from('platforms')
        .insert(platformData)
        .select();
    },
    
    updatePlatform: async (platformId: string, platformData: { name?: string, description?: string }) => {
      return await supabase
        .from('platforms')
        .update({
          ...platformData,
          updated_at: new Date().toISOString()
        })
        .eq('id', platformId)
        .select();
    },
    
    deletePlatform: async (platformId: string) => {
      return await supabase
        .from('platforms')
        .delete()
        .eq('id', platformId);
    },
    
    // Files
    getFiles: async (platformId?: string) => {
      let query = supabase.from('files').select('*');
      
      if (platformId) {
        query = query.eq('platform_id', platformId);
      }
      
      return await query.order('created_at', { ascending: false });
    },
    
    searchFiles: async (searchParams: { query?: string, tag?: string, date?: Date | null }) => {
      let query = supabase.from('files').select('*');
      
      if (searchParams.query) {
        query = query.ilike('name', `%${searchParams.query}%`);
      }
      
      if (searchParams.tag) {
        query = query.contains('tags', [searchParams.tag]);
      }
      
      if (searchParams.date) {
        const startOfDay = new Date(searchParams.date);
        startOfDay.setHours(0, 0, 0, 0);
        
        const endOfDay = new Date(searchParams.date);
        endOfDay.setHours(23, 59, 59, 999);
        
        query = query.gte('created_at', startOfDay.toISOString())
                   .lte('created_at', endOfDay.toISOString());
      }
      
      return await query.order('created_at', { ascending: false });
    },
    
    uploadFile: async (fileData: { platform_id: string, name: string, file_type: string, content?: string, file_path?: string, file_size?: number, tags?: string[] }) => {
      return await supabase
        .from('files')
        .insert(fileData)
        .select();
    },
    
    updateFile: async (fileId: string, fileData: { name?: string, content?: string, tags?: string[] }) => {
      return await supabase
        .from('files')
        .update({
          ...fileData,
          updated_at: new Date().toISOString()
        })
        .eq('id', fileId)
        .select();
    },
    
    deleteFile: async (fileId: string) => {
      return await supabase
        .from('files')
        .delete()
        .eq('id', fileId);
    }
  },

  // User management
  users: {
    getAll: async () => {
      const { data: profilesData, error: profilesError } = await supabase
        .from('profiles')
        .select('*');

      if (profilesError) {
        console.error("Error fetching profiles:", profilesError);
        return { data: null, error: profilesError };
      }

      const { data: rolesData, error: rolesError } = await supabase
        .from('user_roles')
        .select('*');
      
      if (rolesError) {
        console.error("Error fetching user roles:", rolesError);
        return { data: null, error: rolesError };
      }

      // Get users from auth schema using admin functions
      const { data: authUsers, error: authError } = await supabase.auth.admin.listUsers();
      
      if (authError) {
        console.error("Error fetching auth users:", authError);
        return { data: null, error: authError };
      }

      // Combine data from profiles, roles, and auth users
      const combined = authUsers?.users.map(user => {
        const profile = profilesData?.find(p => p.id === user.id) || {};
        const role = rolesData?.find(r => r.user_id === user.id)?.role || 'staff';
        
        return {
          id: user.id,
          email: user.email,
          firstName: profile.first_name || '',
          lastName: profile.last_name || '',
          avatarUrl: profile.avatar_url || '',
          role: role,
          createdAt: user.created_at,
          lastSignIn: user.last_sign_in_at
        };
      });

      return { data: combined, error: null };
    },
    
    updateRole: async (userId: string, role: 'admin' | 'manager' | 'staff') => {
      // Check if role exists for user
      const { data: existingRole } = await supabase
        .from('user_roles')
        .select('*')
        .eq('user_id', userId)
        .single();
      
      if (existingRole) {
        // Update existing role
        return await supabase
          .from('user_roles')
          .update({ role })
          .eq('user_id', userId);
      } else {
        // Insert new role
        return await supabase
          .from('user_roles')
          .insert({ user_id: userId, role });
      }
    },
    
    updateProfile: async (userId: string, profileData: { first_name?: string, last_name?: string, avatar_url?: string }) => {
      return await supabase
        .from('profiles')
        .update(profileData)
        .eq('id', userId);
    },
    
    invite: async (email: string, role: 'admin' | 'manager' | 'staff' = 'staff') => {
      // Create a new user
      const { data, error } = await supabase.auth.admin.inviteUserByEmail(email);
      
      if (error) {
        console.error("Error inviting user:", error);
        return { data: null, error };
      }
      
      // Set the user's role
      if (data?.user?.id) {
        const { error: roleError } = await supabase
          .from('user_roles')
          .insert({ user_id: data.user.id, role });
        
        if (roleError) {
          console.error("Error setting user role:", roleError);
          return { data, error: roleError };
        }
      }
      
      return { data, error: null };
    },
    
    delete: async (userId: string) => {
      // Delete user from auth schema
      return await supabase.auth.admin.deleteUser(userId);
    },
    
    hasRole: async (userId: string, role: 'admin' | 'manager' | 'staff') => {
      try {
        const { data, error } = await supabase.rpc('has_role', { _user_id: userId, _role: role });
        
        if (error) throw error;
        
        return { data, error: null };
      } catch (error) {
        console.error("Error checking user role:", error);
        return { data: false, error };
      }
    },
    
    getCurrentUserRole: async () => {
      try {
        const { data: session } = await supabase.auth.getSession();
        if (!session?.session?.user) {
          console.log("User not authenticated in getCurrentUserRole");
          return { data: null, error: new Error('User not authenticated') };
        }
        
        const userId = session.session.user.id;
        const userEmail = session.session.user.email;
        console.log("Checking role for user:", userId, userEmail);
        
        // Force admin role for specific user - make sure this works
        if (userEmail === 'flowasite@gmail.com') {
          console.log("Admin role forced for flowasite@gmail.com in getCurrentUserRole");
          return { data: 'admin', error: null };
        }
        
        // Check each role in order of privilege
        const { data: isAdmin } = await supabase.rpc('has_role', { _user_id: userId, _role: 'admin' });
        if (isAdmin) {
          console.log("User has admin role");
          return { data: 'admin', error: null };
        }
        
        const { data: isManager } = await supabase.rpc('has_role', { _user_id: userId, _role: 'manager' });
        if (isManager) {
          console.log("User has manager role");
          return { data: 'manager', error: null };
        }
        
        console.log("User has staff role");
        return { data: 'staff', error: null };
      } catch (error) {
        console.error("Error in getCurrentUserRole:", error);
        return { data: 'staff', error };
      }
    }
  }
};
